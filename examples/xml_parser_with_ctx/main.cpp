//
// Created by pkuyo on 2025/2/4.
//

// The dataset.xml file is Generated by Mockaroo.

#include "parser.h"
#include <string>
#include <variant>
#include <iostream>
#include <stack>
#include <chrono>
#include "xml_def.h"


namespace xml {


/*
 * ---Terminal Symbol:
 *
 * skip_space       = ('\n' | '\r' | ' ')*
 *
 * tag_name         = [A-Za-z_:][A-Za-z0-9_:.-]*
 * quoted_str       = '"' [^"]* '"' | "'" [^']* "'"
 *
 * text             = [^<]+
 *
 * ---Non-terminal Symbol:
 *
 * attribute        = tag_name '=' quoted_str skip_space
 *
 * attributes       = (skip_space_must attribute)*
 *
 * node             = text | element
 *
 * content          = skip_space node* skip_space
 *
 * open_tag         = open_tag_check tag_name skip_space attributes
 *
 * close_tag        = '</' tag_name '>'
 *
 * element          = open_tag ( '/>' | '>' content close_tag ) skip_space
 *
 * document         = skip_space ( '<?xml' [^?]+ '?>' skip_space)* element
 */

    using namespace pkuyo::parsers;
    using namespace std;
    using XmlStack = std::stack<std::shared_ptr<xml::Element>>;


    struct open_tag_check : public base_parser<char,open_tag_check> {
        optional<nullptr_t> parse_impl(auto& stream,auto&,auto&) const {
            if(peek_impl(stream)) {
                stream.Seek(1);
                return nullptr;
            }
            return std::nullopt;
        }
        bool peek_impl(auto& stream) const {
            if(stream.Eof(1) || stream.Peek()  != '<' ||  stream.Peek(1) == '/' )
                return false;
            return true;
        }
    };


// space
    constexpr auto skip_space = -*SingleValue<char>([](auto &&c) { return c == '\n' || c == '\r' || c == ' '; });


    struct lazy_element;

    constexpr auto tag_name = (+SingleValue<char>([](auto c) {return isalpha(c) || c == '_' || c == ':';})).Name("tag_name");

    constexpr auto quoted_str = (('"' >> Until<char>('"') >> '"') | ('\'' >> Until<char>('\'') >> '\'')).Name("quoted_str");

    constexpr auto attribute =  ( (tag_name >> '=' >> quoted_str >> skip_space)
                                          >>= [] (tuple<std::string, std::string> && part, XmlStack & ctx) {
                ctx.top()->attributes.emplace_back(std::move(part));
                return nullptr;
            }).Name("attribute");

    constexpr auto attributes = (*attribute).Name("attributes");

    constexpr auto text = Until<char>('<').Name("text");

    constexpr auto node =
           ((text >>= [](const auto &str, auto &ctx) {
                    ctx.top()->children.emplace_back(str);
                return nullptr;
            }) | Lazy<char, lazy_element>()).Name("node");

    constexpr auto content = (skip_space >> *node >> skip_space).Name("content");

    constexpr auto open_tag = (open_tag_check()
            >> (tag_name >>= [](const auto & str, auto & ctx){

                auto new_element = make_shared<Element>(str);
                if(!ctx.empty())
                    ctx.top()->children.emplace_back(new_element);
                ctx.push(new_element);
                return nullptr;
            })
            >> skip_space >> attributes).Name("open_tag");

    constexpr auto close_tag = ("</"
            >> -(tag_name && [](const auto & str,auto & ctx) {
                auto result = ctx.top()->tag_name == str;
                if(ctx.size() != 1)
                    ctx.pop();
                return result;
            })
            >> '>').Name("close_tag");

    constexpr auto element = (open_tag >>
            (
                (SeqCheck<char>("/>" )  <<= [](auto,auto & ctx) { ctx.pop();}) |
                '>' >> content >> close_tag
            )
            >> skip_space).Name("element");

    struct lazy_element : public base_parser<char,lazy_element> {
        optional<nullptr_t> parse_impl(auto & stream,auto& g_ctx,auto& ctx) const {
            return element.Parse(stream,g_ctx,ctx);
        }
        bool peek_impl(auto & stream) const {
            return element.Peek(stream);
        }
    };

    constexpr auto document = skip_space >> *("<?xml" >> -Until<char>('?') >> "?>" >> skip_space) >> element;
}

int main() {

    xml::XmlStack element_stack;

    // The dataset.xml file is Generated by Mockaroo.
    pkuyo::parsers::mmap_file_stream xml("dataset.xml");

    auto start = std::chrono::high_resolution_clock::now();
    auto result = xml::document.Parse(xml, element_stack);
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double, std::milli> duration = end - start;
    std::cout << "Run time: " << duration.count() << " ms" << std::endl;

    if (result) {
        std::cout << "XML parsed successfully!\n";
        //xml::PrintElement(*element_stack.top());
    } else {
        std::cout << "Parse failed\n";
    }




    return 0;
}